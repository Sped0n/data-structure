# 算法基本概念

## 五个特性：

* 有穷性
* 确定性
* 可行性
* 输入
* 输出

## 评价算法的优劣

### 时间复杂度

**定义**：

定性描述算法的运行时间。一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。一个算法中的语句执行次数称为语句频度或时间频度，记为T(n)。

**分类**：

* 最坏时间复杂度

  最坏情况下，算法的时间复杂度。

* 平均时间复杂度

  平均时间复杂度是指所有输入实力在等概率出现的情况下，算法的期望运行时间。

* 最好时间复杂度

  最好情况下，算法的时间复杂度。

**计算**：

* 常数阶**O(1)**

  无论代码执行了多少行，只要是没有循环等复杂结构，那这个代码的时间复杂度就都是O(1)，如：

  ```c
  int i = 1;
  int j = 2;
  ++i;
  j++;
  int m = i + j;
  ```

  > 上述代码在执行的时候，它消耗的时候并不随着某个变量的增长而增长，那么无论这类代码有多长，即使有几万几十万行，都可以用O(1)来表示它的时间复杂度。

* 线性阶**O(n)**

  这段代码，for循环里面的代码会执行n遍，<u>因此它消耗的时间是随着n的变化而变化的</u>，因此这类代码都可以用O(n)来表示它的时间复杂度。
  
  ```c
  for(i = 1; i <= n; ++i) {
     j = i;
     j++;
  }
  ```

* 对数阶**O(logN)** 
  
  从上面代码可以看到，在while循环里面，每次都将 i 乘以 2，乘完之后，i 距离 n 就越来越近了。我们试着求解一下，假设循环x次之后，i 就大于 2 了，此时这个循环就退出了，也就是说 2 的 x 次方等于 n，那么 $x = \log_2n$
  
  也就是说当循环$\log_2n$次以后，这个代码就结束了。因此这个代码的时间复杂度为：**O(logn)**
  
  ```c
  int i = 1;
  while(i < n) {
      i = i * 2;
  }
  ```
  
  > 可实际上，不论是以 2 为底、以 3 为底，还是以 10 为底，所有对数阶的时间复杂度都是记为$O(\log n)$。为什么呢？ 
  >
  > 答：因为对数之间是可以相互转换的。因为$\log_32\times \log_2n = \log_3n$，所以$O(\log_3n)=O(\log_32\times\log_2n)$。而$\log_32$是个常数，<u>我们在前面也提到过常量系数在大O表示法中是可以被忽略的</u>，所以$O(\log_2n)=O(\log_3n)$。所以在量级为对数阶的复杂度里，我们干脆忽略对数的底，统一表示为$O(\log n)$。


* 平方阶**O(n^2)** / 立方阶**O(n^3)**

  循环执行次数最多的代码为a++，执行次数为$n^2$，所以$T(n)=O(n^2)$。 立方阶同理，只要再多套一层for循环即可。

  ```c
  int a = 0;
  for (int i = 0; i < n; i++) {
      for(int j = 0; j < n; j++) {
          a++;  
      }
  }
  
  ```

* 指数阶**O(2^n)**

  简单例子：

  ```c
  for (int i = 0; i < 2^n; i++) {
    	n++;
  }
  ```

  经典的汉诺塔问题：

  ```c
  void hanoi(int n, char x, char y, char z) { 
      if(n == 1)
    		cout<<x<<z; 
      else {
    		hanoi(n - 1, x, z, y); 
        cout<<x, z; 
        hanoi(n - 1, y ,x ,z);
    	} 
    }
  ```
	时间复杂度取决于递归的深度，也就是问题规模$n$的大小。
	> 可以用递推式$T(n)=2T(n-1)+1$来计算时间复杂度。首先，当$n=1$时，需要1次基本操作，即把一个盘子从$x$移到$z$。当$n>1$时，需要先把上面的$n-1$个盘子从$x$移到$y$上（这一步递归调用一次函数$hanoi(n-1,x,z,y)$），然后把最底下的一个盘子从$x$移到$z$上（这一步是$cout<<x<<z$），最后把余下的$n-1$个盘子从$y$移到$z$（这一步递归调用一次函数$hanoi(n-1,y,x,z)$）。
  >
  > 对递推式做一些展开：
  >
  > $$\begin{aligned} T(n)&=2T(n-1)+1 \\ &=2(2T(n-2)+1)+1=2^2T(n-2)+2+1 \\ &=2^2(2T(n-3)+1)+2+1=2^3T(n-3)+2^2+2+1 \\ &=2^3(2T(n-4)+1)+2^2+2+1=2^4T(n-4)+2^3+2^2+2+1 \\ &\cdots \\ &=2^nT(1)+2^{n-1}+2^{n-2}+\cdots+2+1 \\ &=2^n-1 \end{aligned}$$
  >
  > 因此，该函数的时间复杂度是$O(2^n)$。
  

