# 算法基本概念

## 五个特性：

* 有穷性
* 确定性
* 可行性
* 输入
* 输出

## 评价算法的优劣

### 时间复杂度

**定义**：

定性描述算法的运行时间。一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。一个算法中的语句执行次数称为语句频度或时间频度，记为T(n)。

**分类**：

* 最坏时间复杂度

  最坏情况下，算法的时间复杂度。

* 平均时间复杂度

  平均时间复杂度是指所有输入实力在等概率出现的情况下，算法的期望运行时间。

* 最好时间复杂度

  最好情况下，算法的时间复杂度。

**计算**：

* 常数阶**O(1)**

  无论代码执行了多少行，只要是没有循环等复杂结构，那这个代码的时间复杂度就都是O(1)，如：

  ```c
  int i = 1;
  int j = 2;
  ++i;
  j++;
  int m = i + j;
  ```

  > 上述代码在执行的时候，它消耗的时候并不随着某个变量的增长而增长，那么无论这类代码有多长，即使有几万几十万行，都可以用O(1)来表示它的时间复杂度。

* 线性阶**O(n)**

  这段代码，for循环里面的代码会执行n遍，<u>因此它消耗的时间是随着n的变化而变化的</u>，因此这类代码都可以用O(n)来表示它的时间复杂度。
  
  ```c
  for(i = 1; i <= n; ++i) {
     j = i;
     j++;
  }
  ```

* 对数阶**O(logN)** 
  
  从上面代码可以看到，在while循环里面，每次都将 i 乘以 2，乘完之后，i 距离 n 就越来越近了。我们试着求解一下，假设循环x次之后，i 就大于 2 了，此时这个循环就退出了，也就是说 2 的 x 次方等于 n，那么 $x = \log_2n$
  
  也就是说当循环$\log_2n$次以后，这个代码就结束了。因此这个代码的时间复杂度为：**O(logn)**
  
  ```c
  int i = 1;
  while(i < n) {
      i = i * 2;
  }
  ```
  
  > 可实际上，不论是以 2 为底、以 3 为底，还是以 10 为底，所有对数阶的时间复杂度都是记为$O(\log n)$。为什么呢？ 
  >
  > 答：因为对数之间是可以相互转换的。因为$\log_32\times \log_2n = \log_3n$，所以$O(\log_3n)=O(\log_32\times\log_2n)$。而$\log_32$是个常数，<u>我们在前面也提到过常量系数在大O表示法中是可以被忽略的</u>，所以$O(\log_2n)=O(\log_3n)$。所以在量级为对数阶的复杂度里，我们干脆忽略对数的底，统一表示为$O(\log n)$。


* 平方阶**O(n^2)** / 立方阶**O(n^3)**

  循环执行次数最多的代码为a++，执行次数为$n^2$，所以$T(n)=O(n^2)$。 立方阶同理，只要再多套一层for循环即可。

  ```c
  int a = 0;
  for (int i = 0; i < n; i++) {
      for(int j = 0; j < n; j++) {
          a++;  
      }
  }
  
  ```

* 指数阶**O(2^n)**

  简单例子：

  ```c
  for (int i = 0; i < 2^n; i++) {
    	n++;
  }
  ```

  经典的汉诺塔问题：

  ```c
  void hanoi(int n, char x, char y, char z) { 
      if(n == 1)
    		cout<<x<<z; 
      else {
    		hanoi(n - 1, x, z, y); 
        cout<<x, z; 
        hanoi(n - 1, y ,x ,z);
    	} 
    }
  ```
	时间复杂度取决于递归的深度，也就是问题规模$n$的大小。
	> 可以用递推式$T(n)=2T(n-1)+1$来计算时间复杂度。首先，当$n=1$时，需要1次基本操作，即把一个盘子从$x$移到$z$。当$n>1$时，需要先把上面的$n-1$个盘子从$x$移到$y$上（这一步递归调用一次函数$hanoi(n-1,x,z,y)$），然后把最底下的一个盘子从$x$移到$z$上（这一步是$cout<<x<<z$），最后把余下的$n-1$个盘子从$y$移到$z$（这一步递归调用一次函数$hanoi(n-1,y,x,z)$）。
  >
  > 对递推式做一些展开：
  >
  > $$\begin{aligned} T(n)&=2T(n-1)+1 \\ &=2(2T(n-2)+1)+1=2^2T(n-2)+2+1 \\ &=2^2(2T(n-3)+1)+2+1=2^3T(n-3)+2^2+2+1 \\ &=2^3(2T(n-4)+1)+2^2+2+1=2^4T(n-4)+2^3+2^2+2+1 \\ &\cdots \\ &=2^nT(1)+2^{n-1}+2^{n-2}+\cdots+2+1 \\ &=2^n-1 \end{aligned}$$
  >
  > 因此，该函数的时间复杂度是$O(2^n)$。
  
* 阶乘阶**O(n!)**

  循环执行次数最多的语句为`factorial(n - 1)`，在当前 n 下，会调用n次`factorial(n - 1)`，而在每个 n - 1 下，又会调用n - 1次`factorial(n - 2)`，以此类推，得执行次数为$n\times (n-1) \times (n-2) \times \cdots \times 1$，即$n!$。
  
  ```c
  int factorial(int n) {
      for (int i = 0; i < n; i++) {
  				factorial(n - 1);
      }  
  }
  ```

**时间效率排名**：

![7XotOxdBhZgbDlw](https://img.sped0nwen.com/image/2023/06/01/pdmvis-0.webp)

### 最好、最坏以及平均时间复杂度

此外，我们还需要知道，同一段代码在不同情况下会有不一样的时间复杂度，让我们看下面这段代码。
```c
// Tell whether the array a contains x.
boolean contains(int[] a, x) {
    for (int i = 0; i < a.length; i++) {
        if (x == a[i])
            return true;
    }
    return false
}
```

首先，执行次数最多的语句很明显为`if (x == a[i])`。 接着问题来了，假如我们想找的元素x正好就处于数组的第一个位置，那么无论数组规模多大，该语句的执行次数都为1，此时$T(n)=O(1)$，这种情况就是最好时间复杂度（best-case time complexity）；假如我们想找的元素x不在数组中，那么这整个数组都会被遍历一遍，``if (x == a[i])``的执行次数为𝑛，则$T(n)=O(n)$，这种情况就是最坏时间复杂度（worst-case time complexity），我们通常会以最坏的角度来进行时间复杂度的评估。

平均时间复杂度通常来说较难计算，因为难以得出各类情况的分布概率，有时为了简便，会将最好时间复杂度以及最坏时间复杂度相加除以二来得出平均时间复杂度。

### 空间复杂度

空间复杂度全称就是渐进空间复杂度，用来表示算法的存储空间与数据规模之间的增长关系。和时间复杂度一样，空间复杂度也是用大 `O` 进行表示。

其实学会了分析时间复杂度，那么空间复杂度的分析就简单了，主要就看我们在一个算法当中到底有没有使用到了额外的空间来进行存储数据，然后判断这个额外空间的大小会不会随着 `n` 的变化而变化，从而得到空间复杂度。

我们来看一个给数组赋值例子，假设这就是一个算法，我们可以来分析下这个算法的空间复杂度：

```c
void init(int n){
    int a = 0;
    int arr[] = new int[n];
    for (int i=0;i<n;i++){
        arr[i]=n;
    }
}
```

一开始定义了一个变量，这里需要空间，但是这是一个常量级的（不随 `n` 的变化而变化），然后再定义了一个数组，数组的长度为 `n`，这里数组也需要占用空间，而且数组的空间是随着 `n` 的变化而变化的，其余代码没有占用额外空间，所以我们就可以认为上面示例中的空间复杂度为 `O(n)`。

对于算法的空间复杂度也可以简单的进行总结一下：

- 如果申请的是有限个数（常量）的变量，空间复杂度为 `O(1)`。
- 如果申请的是一维数组，队列或者链表等，那么空间复杂度为 `O(n)`。
- 如果申请的是二维数组，那么空间复杂度为 `O(n²)`。
- 如果是在循环体中申请的数组等，可能就需要取嵌套的乘积来作为空间复杂度，这种就需要具体的进一步分析。

### 总结

复杂度其实相当于一个算法在n不断上升的时候`scalability`的能力，有的拓展性好，有的拓展性差，性能需求会随着n的上升暴涨。
